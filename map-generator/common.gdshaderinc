const int CASCADE_COUNT = 3;


group_uniforms Internal;
/******************************************************************************/
// These are intended to be updated during runtime. Setting values in the editor
// may not have the desired result.

// For inverting surface normals, for underwater effect
uniform float normal_factor = 1.0;

// The UV scales for each cascade.
// Updated on initialization only by Ocean3D._ready()
uniform float cascade_uv_scales[CASCADE_COUNT];

// The overall UV scale for all cascades.
// Updated on initialization only by Ocean3D._ready()
uniform float uv_scale = 0.001953125;

// The "accumulated wind" that has blown, for wave scrolling from wind.
// Updated each frame by Ocean3D._process()
uniform vec2 wind_uv_offset = vec2(0.0, 0.0);

// The displacement map cascades generated by the compute shaders.
// Updated with each call to Ocean3D.simulate()
uniform sampler2D cascade_displacements[CASCADE_COUNT];

// The maximum distance from the camera a fragment can be visible. Beyond this
// distance the fragment will have ALPHA = 0.0
// This is set on initialization only by Quadtree3D._ready()
uniform float view_distance_max = 16000.0;


group_uniforms Internal.DomainWarp;
/******************************************************************************/
// Apply a static domain warp texture to the displacement map UV reads in order
// to break up tiling artifacts when viewing large distances.
// Static domain warp is used rather than animated or player centered to avoid
// vertex/UV swimming artifacts.

// Controls how large the domain_warp_texture is stretched horizontally.
// Smaller numbers result in more horizontal stretching.
// To stretch the texture to cover X units, set this value to 1.0 / X
uniform float domain_warp_uv_scale : hint_range(0.0, 1.0, 0.00000001) = 0.0000625;

// Controls how much distortion is applied to the displacement map UV reads
uniform float domain_warp_strength = 1500.0;

// Noise texture used to domain warp the displacement map UV reads to break up
// tiling at large distances from the camera.
uniform sampler2D domain_warp_texture;

group_uniforms;


// Get the total wave displacement of a vertex from all cascades.
vec3 get_displacement(vec2 uv) {
	vec3 displacement = vec3(0.0);
	
	for (int i = 0; i < CASCADE_COUNT; i++) {
		displacement += texture(cascade_displacements[i],
				uv * uv_scale * (1.0 / cascade_uv_scales[i]) + wind_uv_offset * cascade_uv_scales[i]).rgb;
	}
	
	return displacement;
}


// Calculate surface normals and Jacobian determinant for a given coordinate.
// The normal will be packed in the XYZ channels, and the Jacobian determinant
// will be packed in the W channel.
vec4 get_normals_jacobian(vec2 uv, vec3 displacement) {
	// Surface Normals
	float offset = 1.0;
	
	vec3 right = (vec3(offset, get_displacement(uv + vec2(offset, 0.0)).y, 0.0)) - displacement;
	vec3 left = (vec3(-offset, get_displacement(uv + vec2(-offset, 0.0)).y, 0.0)) - displacement;
	vec3 bottom = (vec3(0.0, get_displacement(uv + vec2(0.0, offset)).y, offset)) - displacement;
	vec3 top = (vec3(0.0, get_displacement(uv + vec2(0.0, -offset)).y, -offset)) - displacement;
	
	vec3 top_right = cross(right, top);
	vec3 top_left = cross(top, left);
	vec3 bottom_left = cross(left, bottom);
	vec3 bottom_right = cross(bottom, right);
	
	vec3 normal = normalize(top_right + top_left + bottom_left + bottom_right) * normal_factor;
	
	// Jacobian Determinant
	// Used for foam/whitecap rendering
	float jxx = right.x / offset;
	float jxy = right.y / offset;
	float jyx = bottom.x / offset;
	float jyy = bottom.y / offset;
	float jacobian_determinant = (jxx * jyy) - (jxy * jyx);
	
	return vec4(normal, jacobian_determinant);
}


// Apply domain warp to the given coordinate. This has no effect at 0 distance,
// and gets stronger linearly as distance increases. It will reach 100% strength
// at view_distance_max.
vec2 domain_warp(vec2 uv, float linear_dist) {
	vec2 domain_warp = vec2(
			texture(domain_warp_texture, uv * domain_warp_uv_scale).r,
			texture(domain_warp_texture, -uv * domain_warp_uv_scale).r);
	
	domain_warp *= domain_warp_strength * (linear_dist / view_distance_max);
	
	return uv + domain_warp;
}